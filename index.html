<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Dino Runner with Explosion</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #87ceeb;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      user-select: none;
      -webkit-touch-callout: none;
    }
    #wrapper {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }
    #gameCanvas {
      width: 100%;
      aspect-ratio: 4 / 1; /* 600x150 ratio */
      background: transparent;
      border-radius: 8px;
      border: 3px solid #444;
      display: block;
    }
    .score {
      position: absolute;
      top: 8px;
      left: 8px;
      font-size: 16px;
      font-weight: bold;
      color: #222;
      background: rgba(255,255,255,0.8);
      padding: 4px 8px;
      border-radius: 6px;
      pointer-events: none;
    }
    .best {
      position: absolute;
      top: 32px;
      right: 8px;
      font-size: 12px;
      color: #222;
      background: rgba(255,255,255,0.8);
      padding: 4px 8px;
      border-radius: 6px;
      pointer-events: none;
    }
    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #222;
    }
  </style>
</head>
<body>
  <h1 style="margin:8px 0; font-size:1.2rem;">Dino Runner Remix with Explosion</h1>
  <div id="wrapper">
    <canvas id="gameCanvas"></canvas>
    <div class="score" id="scoreDisplay">Score: 0</div>
    <div class="best">Best: <span id="bestDisplay">0</span></div>
  </div>
  <div class="hint">Tap / Space / â†‘ to jump. Enter to restart.</div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const bestDisplay = document.getElementById('bestDisplay');

    // internal logical size (will match display via CSS)
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width * 0.25; // 4:1 ratio
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const groundY = canvas.height * 0.8;

    const dino = {
      x: 50,
      y: groundY,
      width: 40,
      height: 40,
      velocityY: 0,
      gravity: 1000,
      jumpStrength: 450,
      isJumping: false
    };

    let obstacles = [];
    let obstacleSpeed = 300;
    let obstacleTimer = 0;
    const spawnBase = 1.5;
    let score = 0;
    let best = parseInt(localStorage.getItem('best') || '0', 10);
    let gameOver = false;
    let lastTimestamp = null;

    // explosion particles
    let explosionParticles = [];
    let explosionDuration = 0.6; // seconds
    let explosionTime = 0;

    // images
    const dinoImg = new Image();
    dinoImg.src = 'dino.png';
    let dinoImgLoaded = false;
    dinoImg.onload = () => { dinoImgLoaded = true; };

    const obstacleImg = new Image();
    obstacleImg.src = 'cactus.png';
    let obstacleImgLoaded = false;
    obstacleImg.onload = () => { obstacleImgLoaded = true; };

    // cloud offset for background animation
    let cloudOffset = 0;

    function drawBackground(delta) {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#a0d8ff');
      grad.addColorStop(1, '#e8f7ff');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      cloudOffset = (cloudOffset + delta * 40) % canvas.width;
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (let i = 0; i < 5; i++) {
        const cx = ((i * 200) - cloudOffset + canvas.width) % canvas.width;
        drawCloud(cx, canvas.height * 0.15, 1);
        drawCloud(cx + 100, canvas.height * 0.12, 0.8);
      }

      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(0, groundY + 1, canvas.width, canvas.height - groundY - 1);
    }

    function drawCloud(x, y, scale = 1) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.beginPath();
      ctx.arc(0, 0, 12, Math.PI * 0.5, Math.PI * 1.5);
      ctx.arc(16, -6, 16, Math.PI * 1.0, Math.PI * 1.85);
      ctx.arc(32, 0, 12, Math.PI * 1.5, Math.PI * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawDino() {
      if (dinoImgLoaded) {
        ctx.drawImage(dinoImg, dino.x, dino.y - dino.height, dino.width, dino.height);
      } else {
        ctx.fillStyle = '#444';
        ctx.fillRect(dino.x, dino.y - dino.height, dino.width, dino.height);
        ctx.fillStyle = '#fff';
        ctx.fillRect(dino.x + dino.width - 10, dino.y - dino.height + 10, 5, 5); // eye
      }
    }

    function drawCactus(x, baseY, width, height) {
      ctx.fillStyle = '#2e8b57';
      const bodyW = width * 0.6;
      const armW = width * 0.2;
      const armH = height * 0.4;
      ctx.fillRect(x + (width - bodyW) / 2, baseY - height, bodyW, height);
      ctx.fillRect(x + (width - bodyW) / 2 - armW, baseY - height + armH, armW, armH);
      ctx.fillRect(x + (width - bodyW) / 2 - armW, baseY - height + armH - armW, armW * 2, armW);
      ctx.fillRect(x + (width - bodyW) / 2 + bodyW, baseY - height + armH, armW, armH);
      ctx.fillRect(x + (width - bodyW) / 2 + bodyW - armW, baseY - height + armH - armW, armW * 2, armW);
      ctx.fillStyle = '#a0eea0';
      for (let i = 0; i < 3; i++) {
        ctx.fillRect(x + (width - bodyW) / 2 + bodyW / 2 - 2, baseY - height + 5 + i * 10, 4, 4);
      }
    }

    function createObstacle() {
      const h = Math.random() * 30 + 25;
      obstacles.push({
        x: canvas.width + 10,
        y: groundY,
        width: 24,
        height: h
      });
    }

    function drawObstacles() {
      obstacles.forEach(o => {
        if (obstacleImgLoaded) {
          ctx.drawImage(obstacleImg, o.x, o.y - o.height, o.width, o.height);
        } else {
          drawCactus(o.x, o.y, o.width, o.height);
        }
      });
    }

    function updateObstacles(delta) {
      obstacles.forEach(o => {
        o.x -= obstacleSpeed * delta;
      });
      if (obstacles.length && obstacles[0].x + obstacles[0].width < 0) {
        obstacles.shift();
        score++;
        if (score > best) {
          best = score;
          localStorage.setItem('best', best);
        }
        if (score % 5 === 0) obstacleSpeed += 20;
      }
    }

    // explosion particle class
    class Particle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 4 + 2;
        this.color = `rgba(255, ${Math.floor(Math.random() * 255)}, 0, 1)`;
        this.velocityX = (Math.random() - 0.5) * 300;
        this.velocityY = (Math.random() - 0.5) * 300;
        this.life = 1; // seconds
        this.opacity = 1;
      }
      update(delta) {
        this.x += this.velocityX * delta;
        this.y += this.velocityY * delta;
        this.life -= delta;
        this.opacity = this.life;
        this.radius *= 0.9;
      }
      draw(ctx) {
        ctx.beginPath();
        ctx.fillStyle = `rgba(255, 69, 0, ${this.opacity})`;
        ctx.shadowColor = 'orange';
        ctx.shadowBlur = 10;
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function createExplosion(x, y) {
      explosionParticles = [];
      for (let i = 0; i < 30; i++) {
        explosionParticles.push(new Particle(x, y));
      }
      explosionTime = 0;
    }

    function updateExplosion(delta) {
      explosionTime += delta;
      explosionParticles.forEach(p => p.update(delta));
      explosionParticles = explosionParticles.filter(p => p.life > 0);
    }

    function drawExplosion() {
      explosionParticles.forEach(p => p.draw(ctx));
    }

    function checkCollision() {
      for (const o of obstacles) {
        if (
          dino.x < o.x + o.width &&
          dino.x + dino.width > o.x &&
          dino.y > o.y - o.height &&
          dino.y - dino.height < o.y
        ) {
          return true;
        }
      }
      return false;
    }

    function drawScore() {
      scoreDisplay.textContent = 'Score: ' + score;
      bestDisplay.textContent = best;
    }

    function resetGame() {
      obstacles = [];
      obstacleSpeed = 300;
      obstacleTimer = 0;
      score = 0;
      gameOver = false;
      dino.y = groundY;
      dino.velocityY = 0;
      dino.isJumping = false;
      explosionParticles = [];
      explosionTime = 0;
      lastTimestamp = null;
      drawScore();
      requestAnimationFrame(gameLoop);
    }

    function gameLoop(ts) {
      if (!lastTimestamp) lastTimestamp = ts;
      const delta = (ts - lastTimestamp) / 1000;
      lastTimestamp = ts;

      resizeCanvas();

      drawBackground(delta);

      // ground line
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, groundY + 1);
      ctx.lineTo(canvas.width, groundY + 1);
      ctx.stroke();

      if (gameOver) {
        // draw explosion animation
        updateExplosion(delta);
        drawExplosion();

        // overlay
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = '24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('haha hupe!!', canvas.width / 2, canvas.height / 2 - 10);
        ctx.font = '14px system-ui';
        ctx.fillText('Tap / Enter to restart', canvas.width / 2, canvas.height / 2 + 15);
        return;
      }

      // physics
      dino.velocityY += dino.gravity * delta;
      dino.y += dino.velocityY * delta;
      if (dino.y > groundY) {
        dino.y = groundY;
        dino.velocityY = 0;
        dino.isJumping = false;
      }

      drawDino();

      obstacleTimer -= delta;
      if (obstacleTimer <= 0) {
        createObstacle();
        obstacleTimer = Math.max(0.5, spawnBase - Math.floor(score / 5) * 0.1);
      }

      updateObstacles(delta);
      drawObstacles();

      if (checkCollision()) {
        gameOver = true;
        createExplosion(dino.x + dino.width / 2, dino.y - dino.height / 2);
      }

      drawScore();
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('keydown', e => {
      if ((e.code === 'Space' || e.code === 'ArrowUp') && !dino.isJumping && !gameOver) {
        dino.velocityY = -dino.jumpStrength;
        dino.isJumping = true;
      }
      if (e.code === 'Enter' && gameOver) resetGame();
    });

    window.addEventListener('touchstart', e => {
      if (!dino.isJumping && !gameOver) {
        dino.velocityY = -dino.jumpStrength;
        dino.isJumping = true;
      }
      if (gameOver) resetGame();
      e.preventDefault();
    }, { passive: false });

    drawScore();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
